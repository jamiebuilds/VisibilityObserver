{"version":3,"sources":["../src/VisibilityObserver.ts","index.js"],"names":["document","getElementById","scrollTo","top","left","target","overlay","text","observer","VisibilityObserver","entries","entry","rect","visibleRect","style","setProperty","y","x","width","height","innerText","JSON","stringify","observe"],"mappings":"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","file":"example.370f162a.js","sourceRoot":"../example","sourcesContent":["/**\n * Either a [DOMRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect)\n * for the visible box of the target element, or `null` if the element has no\n * visible box.\n */\nexport type VisibleRect = DOMRect | null\n\n/**\n * The **VisibilityObserverEntry** interface represents the object passed to the\n * `VisibilityObserver` constructor's callback function, which allows you to\n * access the new dimensions of the visible box of the\n * [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) or\n * [SVGElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGElement)\n * being observed.\n */\nexport interface VisibilityObserverEntry {\n\t/**\n\t * A reference to the\n\t * [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) or\n\t * [SVGElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGElement)\n\t * being observed.\n\t */\n\treadonly target: Element\n\n\t/**\n\t * Either a [DOMRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect)\n\t * for the visible box of the target element, or `null` if the element has no\n\t * visible box.\n\t */\n\treadonly visibleRect: VisibleRect\n}\n\n/**\n * The function called whenever an observed visible box change occurs. The\n * function is called with two parameters:\n *\n * @param entries\n * An array of `VisibilityObserverEntry` objects that can be used to access the\n * new dimensions of the element after each change.\n *\n * @param observer\n * A reference to the `VisibilityObserver` itself, so it will definitely be\n * accessible from inside the callback, should you need it. This could be used\n * for example to automatically unobserve the observer when a certain condition\n * is reached, but you can omit it if you don't need it.\n *\n * The callback will generally follow a pattern along the lines of:\n * @example\n * function(entries, observer) {\n *   for (let entry of entries) {\n *     // Do something to each entry\n *     // and possibly something to the observer itself\n *   }\n * }\n *\n * @example\n * let visibilityObserver = new VisibilityObserver(entries => {\n *   for (let entry of entries) {\n *     if (entry.visibleRect) {\n *       highlightElem.style.display = 'block'\n * \t\t\t highlightElem.style.top = entry.visibleRect.top + 'px'\n * \t\t\t highlightElem.style.left = entry.visibleRect.left + 'px'\n *       highlightElem.style.width = entry.visibleRect.width + 'px'\n *       highlightElem.style.height = entry.visibleRect.height + 'px'\n *     } else {\n *       highlightElem.style.display = 'none'\n *     }\n *   }\n * });\n *\n * visibilityObserver.observe(divElem);\n */\nexport type VisibilityObserverCallback = (\n\tentries: VisibilityObserverEntry[],\n\tobserver: VisibilityObserver,\n) => void\n\n/**\n * The **VisibilityObserver** interface reports changes to the dimensions of the\n * visible of of an [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element)\n * or [SVGElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGElement).\n *\n * > **Note:** The visible box is the box of the visible area of an element on\n * > screen. Which may be hidden by parent elements not including the window\n * > itself.\n */\nexport default class VisibilityObserver {\n\t/**\n\t * The **VisibilityObserver** constructor creates a new `VisibilityObserver`\n\t * object, which can be used to report changes to the visible box of an\n\t * `Element` or `SVGElement`.\n\t *\n\t * @example\n\t * let visibilityObserver = new VisibilityObserver(callback)\n\t *\n\t * @param callback\n\t * The function called whenever an observed visible rect occurs. The function is\n\t * called with two parameters:\n\t * * **entries**\n\t *   An array of `VisibilityObserverEntry` objects that can be used to access\n\t *   the new dimensions of the element after each change.\n\t * * **observer**\n\t *   A reference to the `VisibilityObserver` itself, so it will definitely be\n\t *   accessible from inside the callback, should you need it. This could be\n\t *   used for example to automatically unobserve the observer when a certain\n\t *   condition is reached, but you can omit it if you don't need it.\n\t *\n\t * The callback will generally follow a pattern along the lines of:\n\t * ```js\n\t * function(entries, observer) {\n\t *   for (let entry of entries) {\n\t *     // Do something to each entry\n\t *     // and possibly something to the observer itself\n\t *   }\n\t * }\n\t * ```\n\t *\n\t * @example\n\t * let visibilityObserver = new VisibilityObserver(entries => {\n\t *   for (let entry of entries) {\n\t *     if (entry.visibleRect) {\n\t *       highlightElem.style.display = 'block'\n\t * \t\t\t highlightElem.style.top = entry.visibleRect.top + 'px'\n\t * \t\t\t highlightElem.style.left = entry.visibleRect.left + 'px'\n\t *       highlightElem.style.width = entry.visibleRect.width + 'px'\n\t *       highlightElem.style.height = entry.visibleRect.height + 'px'\n\t *     } else {\n\t *       highlightElem.style.display = 'none'\n\t *     }\n\t *   }\n\t * });\n\t *\n\t * visibilityObserver.observe(divElem);\n\t */\n\tconstructor(callback: VisibilityObserverCallback) {\n\t\tinit(this, callback)\n\t}\n\n\t/**\n\t * The `observe()` method of the VisibilityObserver interface starts observing\n\t * the specified [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element)\n\t * or [SVGElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGElement).\n\t *\n\t * @example\n\t * visibilityObserver.observe(target);\n\t *\n\t * @param target\n\t * A reference to an\n\t * [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element) or\n\t * [SVGElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGElement)\n\t * to be observed.\n\t */\n\tobserve(target: Element) {\n\t\tobserve(this, target)\n\t}\n\n\t/**\n\t * The **unobserve()** method of the VisibilityObserver interface ends the\n\t * observing of a specified [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element)\n\t * or [SVGElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGElement).\n\t */\n\tunobserve(target: Element) {\n\t\tunobserve(this, target)\n\t}\n\n\t/**\n\t * The **disconnect()** method of the VisibilityObserver interface unobserves\n\t * all observed [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element)\n\t * or [SVGElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGElement)\n\t * targets.\n\t */\n\tdisconnect() {\n\t\tdisconnect(this)\n\t}\n}\n\n/**\n * Collects all of an `element`'s parents into an array.\n * Ordered by closest ancestor to furthest.\n * @private\n */\nlet getAncestorElements = (element: Element): Element[] => {\n\tlet ancestorNodes: Element[] = []\n\tlet parentNode = element.parentNode\n\n\twhile (parentNode && parentNode !== document) {\n\t\tif (parentNode instanceof Element) {\n\t\t\tancestorNodes.push(parentNode)\n\t\t}\n\t\tparentNode = parentNode.parentNode\n\t}\n\n\treturn ancestorNodes\n}\n\n/**\n * Gets the `VisibleRect` of an `element`.\n * @private\n */\nlet getVisibleRect = (element: Element): VisibleRect => {\n\tlet ancestorElements = getAncestorElements(element)\n\tlet visibleRect = element.getBoundingClientRect()\n\n\tfor (let index = 0; index < ancestorElements.length; index++) {\n\t\tlet ancestorElement = ancestorElements[index]\n\t\tlet computedStyle = window.getComputedStyle(ancestorElement)\n\n\t\tif (computedStyle.display === \"none\") {\n\t\t\treturn null\n\t\t}\n\n\t\tif (computedStyle.visibility === \"hidden\") {\n\t\t\treturn null\n\t\t}\n\n\t\tif (computedStyle.overflow === \"visible\") {\n\t\t\tcontinue\n\t\t}\n\n\t\tlet parentRect = ancestorElement.getBoundingClientRect()\n\t\tlet intersection = getRectIntersection(parentRect, visibleRect)\n\n\t\tif (!intersection) {\n\t\t\treturn null\n\t\t}\n\n\t\tvisibleRect = intersection\n\t}\n\n\treturn visibleRect\n}\n\n/**\n * Checks if two `VisibleRect`'s are equal.\n * @private\n */\nlet isSameVisibleRect = (a: VisibleRect, b: VisibleRect): boolean => {\n\tif (a === null && b === null) return true\n\tif (a === null || b === null) return false\n\treturn (\n\t\ta.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height\n\t)\n}\n\n/**\n * Get the intersection of two `DOMRect` objects.\n * Returns `null` if there is no intersection.\n * @private\n */\nlet getRectIntersection = (parent: DOMRect, child: DOMRect): DOMRect | null => {\n\t// faster checks\n\tif (child.left >= parent.right) return null\n\tif (child.top >= parent.bottom) return null\n\tif (child.right <= parent.left) return null\n\tif (child.bottom <= parent.top) return null\n\n\tlet top = Math.max(parent.top, child.top) // ↓\n\tlet left = Math.max(parent.left, child.left) // →\n\tlet right = Math.min(parent.right, child.right) // ←\n\tlet bottom = Math.min(parent.bottom, child.bottom) // ↑\n\n\tlet width = right - left\n\tlet height = bottom - top\n\n\tif (width <= 0 || height <= 0) return null\n\n\t// Order: x, y, width, height\n\treturn new DOMRect(left, top, width, height)\n}\n\n/**\n * Internal state of observer.\n * Names are for minification.\n * @private\n */\ninterface InternalState {\n\t/** The callback of the visibility observer*/\n\tc: VisibilityObserverCallback\n\t/** map of target elements to their last measured visible rect */\n\tt: Map<Element, VisibleRect>\n\t/** animation frame request */\n\tr: null | number\n}\n\n/**\n * Internal state of all observers\n * @private\n */\nlet INTERNAL_STATES = new WeakMap<VisibilityObserver, InternalState>()\n\n/**\n * Internal implementation of `VisibilityObserver#unobserve`\n * @private\n */\nlet init = (\n\tobserver: VisibilityObserver,\n\tcallback: VisibilityObserverCallback,\n) => {\n\tINTERNAL_STATES.set(observer, {\n\t\tc: callback,\n\t\tt: new Map(),\n\t\tr: null,\n\t})\n}\n\n/**\n * Internal implementation of `VisibilityObserver#observe`\n * @private\n */\nlet observe = (observer: VisibilityObserver, target: Element) => {\n\tlet state = INTERNAL_STATES.get(observer) as InternalState\n\tstate.t.set(target, null)\n\tif (!state.r) {\n\t\tstart(observer, state)\n\t}\n}\n\n/**\n * Internal implementation of `VisibilityObserver#unobserve`\n * @private\n */\nlet unobserve = (observer: VisibilityObserver, target: Element) => {\n\tlet state = INTERNAL_STATES.get(observer) as InternalState\n\tstate.t.delete(target)\n\tif (!state.t.size) {\n\t\tcancel(state)\n\t}\n}\n\n/**\n * Internal implementation of `VisibilityObserver#disconnect`\n * @private\n */\nlet disconnect = (observer: VisibilityObserver) => {\n\tlet state = INTERNAL_STATES.get(observer) as InternalState\n\tstate.t.clear()\n\tcancel(state)\n}\n\n/**\n * Internal helper to start animation frame requests that call the callback\n * with updates to visible rects.\n * @private\n */\nlet start = (observer: VisibilityObserver, state: InternalState) => {\n\tfunction request() {\n\t\t/**\n\t\t * TODO: This entire thing should be refactored to use ResizeObserver,\n\t\t * MutationObserver, scroll events on the element and window.\n\t\t */\n\t\tstate.r = requestAnimationFrame(() => {\n\t\t\tlet entries: VisibilityObserverEntry[] = []\n\n\t\t\tstate.t.forEach((prevVisibleRect, target) => {\n\t\t\t\tlet visibleRect = getVisibleRect(target)\n\n\t\t\t\tif (!isSameVisibleRect(prevVisibleRect, visibleRect)) {\n\t\t\t\t\tstate.t.set(target, visibleRect)\n\t\t\t\t\tentries.push({\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tvisibleRect,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tstate.c(entries, observer)\n\t\t\trequest()\n\t\t})\n\t}\n\trequest()\n}\n\n/**\n * Internal helper to cancel animation frame requests\n * @private\n */\nlet cancel = (state: InternalState) => {\n\tif (state.r) {\n\t\tcancelAnimationFrame(state.r)\n\t\tstate.r = null\n\t}\n}\n","import VisibilityObserver from \"../src/VisibilityObserver\"\n\ndocument.getElementById(\"green\").scrollTo({ top: 150, left: 150 })\ndocument.getElementById(\"red\").scrollTo({ top: 300, left: 300 })\ndocument.getElementById(\"yellow\").scrollTo({ top: 50, left: 50 })\n\nlet target = document.getElementById(\"target\")\nlet overlay = document.getElementById(\"overlay\")\nlet text = document.getElementById(\"text\")\n\nlet observer = new VisibilityObserver((entries) => {\n\tfor (let entry of entries) {\n\t\tif (entry.target === target) {\n\t\t\tlet rect = entry.visibleRect\n\n\t\t\toverlay.style.setProperty(\"display\", rect ? \"block\" : \"none\")\n\t\t\toverlay.style.setProperty(\"top\", rect ? `${rect.y}px` : null)\n\t\t\toverlay.style.setProperty(\"left\", rect ? `${rect.x}px` : null)\n\t\t\toverlay.style.setProperty(\"width\", rect ? `${rect.width}px` : null)\n\t\t\toverlay.style.setProperty(\"height\", rect ? `${rect.height}px` : null)\n\n\t\t\ttext.innerText = JSON.stringify(rect)\n\t\t}\n\t}\n})\n\nobserver.observe(target)\n"]}